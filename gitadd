#!/bin/bash
#
# Enhanced git add that reports linting errors for added or modified files.

readonly RED_FG=$(tput setaf 1)
readonly RESET_COLOR=$(tput sgr0)

################################################################################
# Prints the usage info for this script.
# Outputs
#   Writes the usage info to stdout
################################################################################
usage() {
  printf 'usage: gitadd [--help | -h] [--git-dir=<path>] [work-tree=<path>]\n'
  printf '              [<files>]\n'
}

################################################################################
# Cleans a file name output by git status.
# Arguments
#   The file name as output by git status
# Outputs
#   Sets the global $cleaned_file_name to a file name that can be used as
#   input to another command
# TODO
#   Does not handle % character
################################################################################
clean_file_name() {
  # Strip surrounding quotes if they are present
  cleaned_file_name="${1#\"}"
  cleaned_file_name="${cleaned_file_name%\"}"

  # Interpret any backslash sequences
  printf -v cleaned_file_name "${cleaned_file_name}"
}

################################################################################
# Prints a linting error if the file is missing a trailing blank line,
# or has more than one trailing blank line.
# Arguments
#   The number of trailing blank lines on stdin
# Outputs
#   Writes a linting error to stdout if the number of trailing blank lines
#   is not 1
################################################################################
check_trailing_blank_lines() {
  mapfile -t stdin_args
  n="${stdin_args[0]}"

  if [[ "$n" -eq 0 ]]; then
    printf "${RED_FG}nbl${RESET_COLOR} ${file}\n"
  elif [[ "$n" -gt 1 ]]; then
    printf "${RED_FG}mbl${RESET_COLOR} ${file}\n"
  fi
}

# Options that this script handles will be passed to git before the add
# command and the parameters, which constitute the path spec, will be passed
# after the command, so parse out the options and parameters using getopt
parsed_args="$(getopt -n gitadd -o h -l help,git-dir:,work-tree: -- "$@")"
getopt_result="$?"

# Show usage if getopt failed to parse the arguments
if [[ ${getopt_result} -ne 0 ]]; then
  usage
  exit "${getopt_result}"
fi

# Set $1...$n
eval set -- "${parsed_args}"

# Process the options
opts=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h | --help)
      usage
      exit 0
      ;;
    --git-dir | --work-tree)
      opts+=("$1" "$2")
      shift 2
      ;;
    # This is the last option, the rest of $parsed_args is parameters
    --)
      shift
      break
      ;;
  esac
done

# Call git with the options, the add command, and the path spec
git "${opts[@]}" add "$@"

# Save the exit code from git to return from this script
exit_code=$?

# Get the added and modified files from the git status
files=$(git status -s | grep '^[AM]' | cut -b 4-)

# Each file will be on its own line, so update the separator
IFS=$'\n'

# Process each file
for file in ${files}; do
  clean_file_name "${file}"

  # Trailing whitespace
  grep -m 1 '\s\+$' "${cleaned_file_name}" 1> /dev/null \
    && printf "${RED_FG}tws${RESET_COLOR} ${file}\n"

  # Tabs
  grep -m 1 $'\t' "${cleaned_file_name}" 1> /dev/null \
    && printf "${RED_FG}tab${RESET_COLOR} ${file}\n"

  # No trailing blank line
  tail -n 2 "${cleaned_file_name}" | grep -c -m 2 '^$' \
    | check_trailing_blank_lines
done

exit $exit_code

