#!/bin/bash
#
# Enhanced git add that reports linting errors for added, modified or
# renamed files.

readonly RED_FG=$(tput setaf 1)
readonly RESET_COLOR=$(tput sgr0)

################################################################################
# Prints the usage info for this script.
# Outputs
#   Writes the usage info to stdout
################################################################################
usage() {
  printf 'usage: gitadd [--help | -h] [--git-dir=<path>] [work-tree=<path>]\n'
  printf '              [-- <add options>...] [<pathspec>...]\n'
}

git_path=$(which git)

if [[ "$?" -ne 0 ]]; then
  exit 127
fi

# Options that this script handles will be passed to git before the add
# command and the parameters, which constitute the path spec, will be passed
# after the command, so parse out the options and parameters using getopt
parsed_args="$(getopt -n gitadd -o h -l help,git-dir:,work-tree: -- "$@")"
getopt_result="$?"

# Show usage if getopt failed to parse the arguments
if [[ ${getopt_result} -ne 0 ]]; then
  usage
  exit "${getopt_result}"
fi

# Set $1...$n
eval set -- "${parsed_args}"

# Process the options
opts=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h | --help)
      usage
      exit 0
      ;;
    --git-dir | --work-tree)
      opts+=("$1" "$2")
      shift 2
      ;;
    # This is the last option, the rest of $parsed_args is parameters
    --)
      shift
      break
      ;;
  esac
done

# Call git with the options, the add command, and the path spec
${git_path} "${opts[@]}" add "$@"

# Save the exit code from git to return from this script
exit_code=$?

# Get the repo root so we can construct absolute paths since the paths from
# the porcelain status are alway relative to the repository root, which may
# be different from the working directory
git_root=$(${git_path} "${opts[@]}" rev-parse --show-toplevel)

# Get the added, modified, or renamed files from the git status.
# Renamed status entries will have a null character between the file names,
# in addition to the null character at the end of the entry. This will cause
# grep to treat the entry as two lines, breaking the entry after the first
# file name. But this is fine because the line with the first file will match,
# and the first file name is the new name when -z is used.
mapfile -d '' files < <(${git_path} "${opts[@]}" status -z --porcelain \
  | grep -z '^[AMR] ' \
  | cut -z -b 4- \
  | xargs -0 -n 1 printf "${git_root}/%s\0")

# Print lint issues for each file
for file in "${files[@]}"; do
  # Trailing whitespace
  grep -m 1 '\s$' "${file}" 1> /dev/null \
    && printf "${RED_FG}tws${RESET_COLOR} %s\n" "${file}"

  # Tabs
  grep -m 1 $'\t' "${file}" 1> /dev/null \
    && printf "${RED_FG}tab${RESET_COLOR} %s\n" "${file}"

  # No trailing blank line
  read num_tbl < <(tail -n 2 "${file}" | grep -c -m 2 '^$')

  if [[ "${num_tbl}" -eq 0 ]]; then
    printf "${RED_FG}nbl${RESET_COLOR} %s\n" "${file}"
  elif [[ "${num_tbl}" -gt 1 ]]; then
    printf "${RED_FG}mbl${RESET_COLOR} %s\n" "${file}"
  fi
done

exit $exit_code

